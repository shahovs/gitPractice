ИНТЕРФЕЙСЫ

Все обычные методы интерфейса автоматически считаются открытыми (public), поэтому, объявляя метод в интерфейсе, указывать модификатор доступа public необязательно. Но при реализации этого метода в классе - указывать public уже обязательно. (про приватные методы будет ниже)

С помощью интерфейсов можно также объявлять константы.
Все константы интерфейса являются public static final. При этом все эти модификаторы писать не обязательно (они все применяются по умолчанию). Естественно, что константы должны быть проинициализированы.

Но важнее не это, а то, что интерфейсы не могут предоставить. В частности, у них отсутствуют поля экземпляра.

В итоге, у интерфейсов могут быть:
- методы экземпляра абстрактные (abstract public)
- методы экземпляра с реализацией по умолчанию (телом), то есть не абстрактные (нужно ключевое слово default)
- методы статические обязательно с реализацией (считаются публичными по умолчанию)(default использовать не нужно)
- приватные методы (статические и не статические) с реализацией (они не наследуются)
- константы (public static final)
- вложенные классы и интерфейсы (считаются public static - указывать модификаторы опять же не обязательно)
- вложенные перечисления (enum) и аннотации (@interface)
-

Статические методы не наследуются классами. То есть они вызываются только через имя интерфейса.
А обычные методы (не статические) по умолчанию (с реализацией) наследуются классами и могут переопределяться в них.
В интерфейсе не может быть методов по умолчанию с такой же сигнатурой, как у методов toString, equals и hashCode класса Object (ведь в любом случае при конфликте вызывался бы метод суперкласса, то есть Object, а не интерфейса).

Если класс реализует два интерфейса с одинаковыми методами (один с реализацией по умолчанию, а другой - абстрактный, или оба с реализацией по умолчанию), то класс обязан реализовать этот метод (иначе будет неоднозначность - метод какого интерфейса использовать). Но если этот же метод унаследован от суперкласса, то будет использоваться именно он (то есть переопределять его в наследнике будет не обязательно)

Приватные методы могут вызывать другие приватные, абстрактные, статические методы или методы по умолчанию (но приватные статические методы могут вызывать только другие статические и приватные статические методы).